<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Desert Canyon Racer 3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-panel {
            padding: 20px;
            color: white;
            text-shadow: 2px 2px 0 #000;
            font-weight: bold;
            font-size: 24px;
        }

        #score-display { text-align: left; }
        #speed-display { text-align: right; }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }

        h1 {
            color: #ff9800;
            font-size: 4rem;
            margin: 0 0 20px 0;
            text-transform: uppercase;
            font-style: italic;
            text-shadow: 4px 4px 0px #3e2723;
            text-align: center;
            line-height: 1;
        }

        p {
            color: white;
            font-size: 1.2rem;
            margin-bottom: 30px;
            text-align: center;
            max-width: 600px;
            padding: 0 20px;
        }

        button {
            background: linear-gradient(to bottom, #ff9800, #f57c00);
            border: none;
            padding: 15px 50px;
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: transform 0.1s;
            text-transform: uppercase;
        }

        button:active { transform: scale(0.95); }
        .hidden { display: none !important; }

        .controls-hint {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.5);
            font-size: 14px;
        }
        
        #debug-log {
            position: absolute;
            bottom: 5px;
            left: 5px;
            color: yellow;
            font-size: 10px;
            font-family: monospace;
            max-width: 300px;
            z-index: 30;
            pointer-events: none;
            background: rgba(0,0,0,0.5);
            padding: 2px;
        }
    </style>
    <!-- Three.js CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="hud-panel" style="display: flex; justify-content: space-between; width: 100%; box-sizing: border-box;">
            <div id="score-display">DISTANCE: 0m</div>
            <div id="speed-display">0 KM/H</div>
        </div>
        <div class="controls-hint">
            PC: Arrow Keys / WASD &nbsp;|&nbsp; Mobile: Tap Left/Right
        </div>
    </div>

    <!-- On screen logger to see errors -->
    <div id="debug-log">System: Initializing...</div>

    <div id="start-screen">
        <h1>Canyon Run</h1>
        <p>Drive as far as you can. Tap Left/Right to steer.</p>
        <button id="start-btn">Start Engine</button>
        <div id="loading-msg" style="margin-top: 15px; color: #ddd; font-size: 14px;">Initializing 3D Engine...</div>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1>CRASHED!</h1>
        <p id="final-score">Distance: 0m</p>
        <button id="restart-btn">Race Again</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- CONFIGURATION ---
        // Using ./ ensures it looks in current directory
        const CAR_MODEL_URL = './assets/car.glb'; 
        
        const COLORS = {
            sky: 0x87CEEB,
            ground: 0xE6C288, 
            road: 0x333333,
            barrier: 0xFFFFFF,
            barrierStripe: 0xFF0000,
            mountain: 0x8B4513 
        };

        const GAME_CONFIG = {
            speed: 0,
            maxSpeed: 80, 
            acceleration: 30,
            turnSpeed: 40,
            roadWidth: 20,
            segmentLength: 30,
            renderDistance: 40, 
            fogDensity: 0.006
        };

        // --- GLOBALS ---
        let scene, camera, renderer;
        let clock, delta;
        let carContainer, carMesh;
        let roadSegments = [];
        let score = 0;
        let distanceTraveled = 0;
        let isGameActive = false;
        let isGameOver = false;
        let carLoaded = false;
        
        const input = { left: false, right: false };

        // DOM Elements
        const scoreEl = document.getElementById('score-display');
        const speedEl = document.getElementById('speed-display');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreEl = document.getElementById('final-score');
        const loadingMsg = document.getElementById('loading-msg');
        const debugLog = document.getElementById('debug-log');
        const startBtn = document.getElementById('start-btn');

        function log(msg) {
            console.log(msg);
            debugLog.innerText = msg;
        }

        function init() {
            try {
                log("Starting Init...");
                
                // Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(COLORS.sky);
                scene.fog = new THREE.FogExp2(COLORS.ground, GAME_CONFIG.fogDensity);

                // Camera
                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 5, 10);

                // Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.shadowMap.enabled = true;
                document.getElementById('canvas-container').appendChild(renderer.domElement);

                // Lights
                const hemiLight = new THREE.HemisphereLight(0xffffff, COLORS.ground, 0.6);
                scene.add(hemiLight);

                const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
                dirLight.position.set(100, 200, 50);
                dirLight.castShadow = true;
                // Optimize shadows for mobile
                dirLight.shadow.mapSize.width = 1024;
                dirLight.shadow.mapSize.height = 1024;
                dirLight.shadow.camera.left = -100;
                dirLight.shadow.camera.right = 100;
                dirLight.shadow.camera.top = 100;
                dirLight.shadow.camera.bottom = -100;
                scene.add(dirLight);

                // Ground
                const planeGeo = new THREE.PlaneGeometry(2000, 2000);
                const planeMat = new THREE.MeshLambertMaterial({ color: COLORS.ground });
                const plane = new THREE.Mesh(planeGeo, planeMat);
                plane.rotation.x = -Math.PI / 2;
                plane.position.y = -0.1;
                plane.receiveShadow = true;
                scene.add(plane);

                clock = new THREE.Clock();

                // Setup Inputs
                window.addEventListener('resize', onWindowResize);
                document.addEventListener('keydown', onKeyDown);
                document.addEventListener('keyup', onKeyUp);
                const canvas = renderer.domElement;
                canvas.addEventListener('touchstart', handleTouch, {passive: false});
                canvas.addEventListener('touchend', handleTouchEnd, {passive: false});

                // Setup UI
                startBtn.addEventListener('click', startGame);
                document.getElementById('restart-btn').addEventListener('click', resetGame);

                // Load Assets
                loadCarSystem();
                
                // Start Loop
                renderer.setAnimationLoop(animate);
                
                log("Init Complete. Waiting for user.");
            } catch (e) {
                log("Error in Init: " + e.message);
            }
        }

        function loadCarSystem() {
            carContainer = new THREE.Group();
            scene.add(carContainer);
            
            loadingMsg.innerText = "Loading custom car...";
            log("Attempting to load: " + CAR_MODEL_URL);

            const loader = new GLTFLoader();
            
            // TIMEOUT FALLBACK: If GLB takes > 2 seconds, use fallback
            const fallbackTimeout = setTimeout(() => {
                if(!carLoaded) {
                    log("Timeout: Using fallback car");
                    loadingMsg.innerText = "Car load slow. Using fallback.";
                    createFallbackCar();
                    carLoaded = true;
                }
            }, 2500);

            loader.load(
                CAR_MODEL_URL,
                (gltf) => {
                    clearTimeout(fallbackTimeout);
                    if(carLoaded) return; // already fell back

                    log("GLB Loaded successfully");
                    carMesh = gltf.scene;
                    
                    // Normalize size
                    const box = new THREE.Box3().setFromObject(carMesh);
                    const size = box.getSize(new THREE.Vector3());
                    const scale = 3.5 / (size.z || 1); 
                    carMesh.scale.set(scale, scale, scale);
                    carMesh.position.y = 0;
                    carMesh.rotation.y = Math.PI; 

                    carMesh.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    carContainer.add(carMesh);
                    carLoaded = true;
                    loadingMsg.innerText = "Ready to Race!";
                    startBtn.style.opacity = "1";
                    startBtn.style.transform = "scale(1.1)";
                    setTimeout(() => startBtn.style.transform = "scale(1)", 200);
                },
                (xhr) => {
                    // Progress
                    // log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                (error) => {
                    clearTimeout(fallbackTimeout);
                    if(carLoaded) return;
                    
                    console.error(error);
                    log("GLB Error: " + error.message);
                    loadingMsg.innerText = "Asset failed. Using fallback.";
                    createFallbackCar();
                    carLoaded = true;
                }
            );
        }

        function createFallbackCar() {
            // Remove existing if any
            while(carContainer.children.length > 0){ 
                carContainer.remove(carContainer.children[0]); 
            }

            carMesh = new THREE.Group();
            // Body
            const bodyGeo = new THREE.BoxGeometry(1.8, 0.8, 3.5);
            const bodyMat = new THREE.MeshPhongMaterial({ color: 0xff0000 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.6;
            body.castShadow = true;
            carMesh.add(body);
            // Cabin
            const cabinGeo = new THREE.BoxGeometry(1.6, 0.6, 1.5);
            const cabinMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const cabin = new THREE.Mesh(cabinGeo, cabinMat);
            cabin.position.set(0, 1.2, -0.3);
            cabin.castShadow = true;
            carMesh.add(cabin);
            
            carContainer.add(carMesh);
            log("Fallback car created");
        }

        class RoadSegment {
            constructor(zPos, type, previousSegment) {
                this.container = new THREE.Group();
                this.zPos = zPos;
                this.type = type; 
                this.length = GAME_CONFIG.segmentLength;
                
                this.startX = previousSegment ? previousSegment.endX : 0;
                this.startAngle = previousSegment ? previousSegment.endAngle : 0;
                
                let curveAmount = 0;
                if(type === 'curveLeft') curveAmount = 0.5;
                if(type === 'curveRight') curveAmount = -0.5;

                this.endAngle = this.startAngle + curveAmount;
                const angleAvg = (this.startAngle + this.endAngle) / 2;
                this.endX = this.startX + (Math.sin(angleAvg) * this.length);

                this.buildMesh();
                this.addObstacles();
                this.addEnvironment();
                
                scene.add(this.container);
            }

            buildMesh() {
                const w = GAME_CONFIG.roadWidth / 2;
                const x1 = this.startX - w; const x2 = this.startX + w; const z1 = this.zPos;
                const x3 = this.endX - w; const x4 = this.endX + w; const z2 = this.zPos - this.length;

                const vertices = new Float32Array([
                    x1, 0.05, z1, x2, 0.05, z1, x3, 0.05, z2,
                    x2, 0.05, z1, x4, 0.05, z2, x3, 0.05, z2
                ]);

                const roadGeo = new THREE.BufferGeometry();
                roadGeo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                roadGeo.computeVertexNormals();

                const roadMat = new THREE.MeshPhongMaterial({ color: COLORS.road });
                this.mesh = new THREE.Mesh(roadGeo, roadMat);
                this.mesh.receiveShadow = true;
                this.container.add(this.mesh);

                // Strip
                const sW = 0.5;
                const sx1 = this.startX - sW; const sx2 = this.startX + sW;
                const sx3 = this.endX - sW; const sx4 = this.endX + sW;
                const sVerts = new Float32Array([
                    sx1, 0.06, z1, sx2, 0.06, z1, sx3, 0.06, z2,
                    sx2, 0.06, z1, sx4, 0.06, z2, sx3, 0.06, z2
                ]);
                const sGeo = new THREE.BufferGeometry();
                sGeo.setAttribute('position', new THREE.BufferAttribute(sVerts, 3));
                const sMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                this.container.add(new THREE.Mesh(sGeo, sMat));

                this.bounds = { zStart: z1, zEnd: z2, leftStart: x1, rightStart: x2, leftEnd: x3, rightEnd: x4 };
            }

            addObstacles() {
                const numBarriers = 3;
                const bGeo = new THREE.BoxGeometry(1, 1.5, 4);
                const bMat = new THREE.MeshLambertMaterial({ color: COLORS.barrierStripe }); 

                for(let i=0; i<numBarriers; i++) {
                    const t = i / numBarriers;
                    const cX_L = THREE.MathUtils.lerp(this.startX, this.endX, t) - (GAME_CONFIG.roadWidth/2) - 1;
                    const cX_R = THREE.MathUtils.lerp(this.startX, this.endX, t) + (GAME_CONFIG.roadWidth/2) + 1;
                    const cZ = THREE.MathUtils.lerp(this.zPos, this.zPos - this.length, t);

                    const bL = new THREE.Mesh(bGeo, bMat);
                    bL.position.set(cX_L, 0.75, cZ);
                    bL.castShadow = true;
                    this.container.add(bL);
                    const bR = bL.clone();
                    bR.position.set(cX_R, 0.75, cZ);
                    this.container.add(bR);
                }
            }

            addEnvironment() {
                if (Math.random() > 0.3) return;
                const geo = new THREE.ConeGeometry(Math.random() * 10 + 5, Math.random() * 30 + 10, 4);
                const mat = new THREE.MeshLambertMaterial({color: COLORS.mountain});
                const rock = new THREE.Mesh(geo, mat);
                const side = Math.random() > 0.5 ? 1 : -1;
                const offset = (GAME_CONFIG.roadWidth/2) + 20 + Math.random() * 30;
                const midX = (this.startX + this.endX)/2;
                rock.position.set(midX + (offset * side), 0, this.zPos - (this.length/2));
                rock.castShadow = true;
                this.container.add(rock);
            }

            destroy() {
                scene.remove(this.container);
                this.container.traverse(o => { if(o.isMesh) { o.geometry.dispose(); o.material.dispose(); } });
            }
        }

        function startGame() {
            if(!carLoaded) {
                log("Car not ready yet!");
                // Force ready if stuck
                createFallbackCar();
                carLoaded = true;
            }

            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            
            score = 0;
            GAME_CONFIG.speed = 0;
            isGameActive = true;
            isGameOver = false;
            distanceTraveled = 0;

            if(carContainer) {
                carContainer.position.set(0, 0, 0);
                carContainer.rotation.set(0, 0, 0);
            }

            roadSegments.forEach(s => s.destroy());
            roadSegments = [];

            let prev = null;
            for(let i=0; i<GAME_CONFIG.renderDistance; i++) {
                const seg = new RoadSegment(i === 0 ? 0 : prev.zPos - prev.length, 'straight', prev);
                roadSegments.push(seg);
                prev = seg;
            }
            log("Game Started");
        }

        function resetGame() { startGame(); }

        function spawnNextSegment() {
            const last = roadSegments[roadSegments.length - 1];
            const rand = Math.random();
            let type = 'straight';
            if (last.endAngle > 1.0) type = 'curveRight';
            else if (last.endAngle < -1.0) type = 'curveLeft';
            else {
                if(rand < 0.2) type = 'curveLeft';
                else if(rand < 0.4) type = 'curveRight';
            }
            roadSegments.push(new RoadSegment(last.zPos - last.length, type, last));
            if(roadSegments.length > GAME_CONFIG.renderDistance + 5) {
                roadSegments.shift().destroy();
            }
        }

        function checkCollisions() {
            if(!carContainer) return;
            const cx = carContainer.position.x;
            const cz = carContainer.position.z;
            const seg = roadSegments.find(s => cz <= s.bounds.zStart && cz >= s.bounds.zEnd);
            if(seg) {
                const t = (seg.bounds.zStart - cz) / seg.length;
                const rLeft = THREE.MathUtils.lerp(seg.bounds.leftStart, seg.bounds.leftEnd, t);
                const rRight = THREE.MathUtils.lerp(seg.bounds.rightStart, seg.bounds.rightEnd, t);
                if (cx < rLeft + 1.5 || cx > rRight - 1.5) crash();
            }
        }

        function crash() {
            isGameActive = false;
            isGameOver = true;
            finalScoreEl.innerText = `Distance: ${Math.floor(score)}m`;
            gameOverScreen.classList.remove('hidden');
        }

        function animate() {
            if(!renderer) return;

            delta = clock.getDelta();

            // Safety check: Don't run game logic if car isn't created yet
            if (isGameActive && !isGameOver && carContainer) {
                if (GAME_CONFIG.speed < GAME_CONFIG.maxSpeed) GAME_CONFIG.speed += GAME_CONFIG.acceleration * delta;
                const moveDist = GAME_CONFIG.speed * delta;
                
                carContainer.position.z -= moveDist;
                distanceTraveled += moveDist;
                score = distanceTraveled;

                const turnAmt = GAME_CONFIG.turnSpeed * delta;
                if (input.left) carContainer.position.x -= turnAmt;
                if (input.right) carContainer.position.x += turnAmt;

                if(carMesh) carMesh.rotation.z = THREE.MathUtils.lerp(carMesh.rotation.z, (input.left ? 0.2 : (input.right ? -0.2 : 0)), delta * 5);

                const lastSeg = roadSegments[roadSegments.length - 1];
                if (Math.abs(carContainer.position.z - lastSeg.zPos) < (GAME_CONFIG.renderDistance * GAME_CONFIG.segmentLength) - 100) {
                   spawnNextSegment();
                }

                checkCollisions();
                scoreEl.innerText = `DISTANCE: ${Math.floor(score)}m`;
                speedEl.innerText = `${Math.floor(GAME_CONFIG.speed * 2)} KM/H`;
            }

            if(carContainer && camera) {
                const tX = carContainer.position.x;
                const tZ = carContainer.position.z + 12;
                camera.position.z = tZ;
                camera.position.x = THREE.MathUtils.lerp(camera.position.x, tX * 0.8, delta * 3);
                camera.lookAt(carContainer.position.x * 0.5, carContainer.position.y, carContainer.position.z - 20);
            }

            renderer.render(scene, camera);
        }

        function onKeyDown(e) { if(e.key.startsWith('Arrow') || 'adAD'.includes(e.key)) { input.left = (e.key==='ArrowLeft'||e.key==='a'||e.key==='A'); input.right = (e.key==='ArrowRight'||e.key==='d'||e.key==='D'); } }
        function onKeyUp(e) { if(e.key.startsWith('Arrow') || 'adAD'.includes(e.key)) { if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') input.left = false; if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') input.right = false; } }
        function handleTouch(e) { e.preventDefault(); input.left = e.touches[0].clientX < window.innerWidth/2; input.right = !input.left; }
        function handleTouchEnd(e) { e.preventDefault(); input.left = false; input.right = false; }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        init();
    </script>
</body>
</html>