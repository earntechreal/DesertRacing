<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Desert Canyon Racer 3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB; /* Sky Blue Fallback */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* Let touches pass through to game */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-panel {
            padding: 20px;
            color: white;
            text-shadow: 2px 2px 0 #000;
            font-weight: bold;
            font-size: 24px;
        }

        #score-display {
            text-align: left;
        }

        #speed-display {
            text-align: right;
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }

        h1 {
            color: #ff9800;
            font-size: 4rem;
            margin: 0 0 20px 0;
            text-transform: uppercase;
            font-style: italic;
            text-shadow: 4px 4px 0px #3e2723;
        }

        p {
            color: white;
            font-size: 1.2rem;
            margin-bottom: 30px;
            text-align: center;
            max-width: 600px;
        }

        button {
            background: linear-gradient(to bottom, #ff9800, #f57c00);
            border: none;
            padding: 15px 50px;
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: transform 0.1s;
            text-transform: uppercase;
        }

        button:active {
            transform: scale(0.95);
        }

        .hidden {
            display: none !important;
        }

        /* Mobile controls hint */
        .controls-hint {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.5);
            font-size: 14px;
        }
        
        #loading-msg {
            color: yellow;
            font-size: 0.9rem;
            margin-top: 10px;
        }

    </style>
    <!-- Three.js CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="hud-panel" style="display: flex; justify-content: space-between; width: 100%; box-sizing: border-box;">
            <div id="score-display">DISTANCE: 0m</div>
            <div id="speed-display">0 KM/H</div>
        </div>
        <div class="controls-hint" id="controls-hint">
            PC: Arrow Keys / WASD &nbsp;|&nbsp; Mobile: Tap Left/Right
        </div>
    </div>

    <div id="start-screen">
        <h1>Canyon Run</h1>
        <p>Drive as far as you can. Avoid the barriers. The road changes from straight to curved.</p>
        <button id="start-btn">Start Engine</button>
        <div id="loading-msg">Loading Assets...</div>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1>CRASHED!</h1>
        <p id="final-score">Distance: 0m</p>
        <button id="restart-btn">Race Again</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- CONFIGURATION ---
        
        // UPDATED PATH FOR YOUR FOLDER STRUCTURE
        const CAR_MODEL_URL = 'assets/car.glb'; 
        
        const COLORS = {
            sky: 0x87CEEB,
            ground: 0xE6C288, // Desert Sand
            road: 0x333333,
            barrier: 0xFFFFFF,
            barrierStripe: 0xFF0000,
            mountain: 0x8B4513 // Red Rock
        };

        const GAME_CONFIG = {
            speed: 0,
            maxSpeed: 80, // Units per second
            acceleration: 30,
            turnSpeed: 40,
            roadWidth: 20,
            segmentLength: 30,
            renderDistance: 40, // How many segments ahead to draw
            fogDensity: 0.006
        };

        // --- GLOBALS ---
        let scene, camera, renderer;
        let clock, delta;
        let carContainer, carMesh;
        let roadSegments = [];
        let score = 0;
        let distanceTraveled = 0;
        let isGameActive = false;
        let isGameOver = false;
        
        // Input State
        const input = { left: false, right: false };

        // DOM Elements
        const scoreEl = document.getElementById('score-display');
        const speedEl = document.getElementById('speed-display');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreEl = document.getElementById('final-score');
        const loadingMsg = document.getElementById('loading-msg');

        // --- INITIALIZATION ---

        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(COLORS.sky);
            scene.fog = new THREE.FogExp2(COLORS.ground, GAME_CONFIG.fogDensity);

            // Camera Setup
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);

            // Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lighting
            const hemiLight = new THREE.HemisphereLight(0xffffff, COLORS.ground, 0.6);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(100, 200, 50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 500;
            // Align shadow camera to cover the visible track area
            const shadowDist = 200;
            dirLight.shadow.camera.left = -shadowDist;
            dirLight.shadow.camera.right = shadowDist;
            dirLight.shadow.camera.top = shadowDist;
            dirLight.shadow.camera.bottom = -shadowDist;
            scene.add(dirLight);

            // Ground Plane (Infinite visual floor)
            const planeGeo = new THREE.PlaneGeometry(2000, 2000);
            const planeMat = new THREE.MeshLambertMaterial({ color: COLORS.ground });
            const plane = new THREE.Mesh(planeGeo, planeMat);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -0.1;
            plane.receiveShadow = true;
            scene.add(plane);

            // Clock
            clock = new THREE.Clock();

            // Load Assets
            loadCar();
            
            // Events
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            // Touch Controls
            const canvas = renderer.domElement;
            canvas.addEventListener('touchstart', handleTouch, {passive: false});
            canvas.addEventListener('touchend', handleTouchEnd, {passive: false});

            // UI Listeners
            document.getElementById('start-btn').addEventListener('click', startGame);
            document.getElementById('restart-btn').addEventListener('click', resetGame);
            
            // Start Loop
            renderer.setAnimationLoop(animate);
        }

        // --- ASSET LOADING ---

        function loadCar() {
            carContainer = new THREE.Group();
            scene.add(carContainer);

            const loader = new GLTFLoader();
            
            // Attempt to load user GLB
            loader.load(
                CAR_MODEL_URL,
                (gltf) => {
                    carMesh = gltf.scene;
                    
                    // Normalize size
                    const box = new THREE.Box3().setFromObject(carMesh);
                    const size = box.getSize(new THREE.Vector3());
                    const scale = 3.5 / size.z; // Target length of 3.5 units
                    carMesh.scale.set(scale, scale, scale);
                    
                    // Center it
                    carMesh.position.y = 0;
                    carMesh.rotation.y = Math.PI; // GLTFs often face +Z, we drive -Z

                    carMesh.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    carContainer.add(carMesh);
                    loadingMsg.innerText = "Car Loaded Ready!";
                },
                undefined,
                (error) => {
                    console.log("GLB not found at " + CAR_MODEL_URL + ", using placeholder.");
                    console.error(error);
                    createFallbackCar();
                    loadingMsg.innerText = "Using Fallback Car (Check Console)";
                }
            );
        }

        function createFallbackCar() {
            // A simple retro style car mesh
            carMesh = new THREE.Group();

            // Body
            const bodyGeo = new THREE.BoxGeometry(1.8, 0.8, 3.5);
            const bodyMat = new THREE.MeshPhongMaterial({ color: 0xff0000 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.6;
            body.castShadow = true;
            carMesh.add(body);

            // Cabin
            const cabinGeo = new THREE.BoxGeometry(1.6, 0.6, 1.5);
            const cabinMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const cabin = new THREE.Mesh(cabinGeo, cabinMat);
            cabin.position.set(0, 1.2, -0.3);
            cabin.castShadow = true;
            carMesh.add(cabin);

            // Wheels
            const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.4, 16);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            
            const positions = [
                [-0.9, 0.4, 1.2], [0.9, 0.4, 1.2],
                [-0.9, 0.4, -1.2], [0.9, 0.4, -1.2]
            ];

            positions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                wheel.position.set(...pos);
                wheel.rotation.z = Math.PI / 2;
                wheel.castShadow = true;
                carMesh.add(wheel);
            });

            // Headlights
            const lightGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 16);
            const lightMat = new THREE.MeshBasicMaterial({ color: 0xffffaa });
            const l1 = new THREE.Mesh(lightGeo, lightMat);
            l1.rotation.x = Math.PI/2;
            l1.position.set(-0.6, 0.6, -1.75);
            const l2 = l1.clone();
            l2.position.set(0.6, 0.6, -1.75);
            carMesh.add(l1);
            carMesh.add(l2);

            carContainer.add(carMesh);
        }

        // --- ROAD GENERATION SYSTEM ---

        class RoadSegment {
            constructor(zPos, type, previousSegment) {
                this.container = new THREE.Group();
                this.zPos = zPos;
                this.type = type; // 'straight', 'curveLeft', 'curveRight'
                this.length = GAME_CONFIG.segmentLength;
                
                // Determine curve offset
                // If previous was curved, we continue from its end angle/offset
                this.startX = previousSegment ? previousSegment.endX : 0;
                this.startAngle = previousSegment ? previousSegment.endAngle : 0;
                
                // Calculate end point based on type
                let curveAmount = 0;
                if(type === 'curveLeft') curveAmount = 0.5; // Radians
                if(type === 'curveRight') curveAmount = -0.5;

                this.endAngle = this.startAngle + curveAmount;
                
                // Approximate new X (simple trig for visuals)
                // In a real spline system we'd use Bezier, but for this arcade style:
                const angleAvg = (this.startAngle + this.endAngle) / 2;
                this.endX = this.startX + (Math.sin(angleAvg) * this.length);

                this.buildMesh();
                this.addObstacles();
                this.addEnvironment();
                
                scene.add(this.container);
            }

            buildMesh() {
                // We draw a road segment connecting (startX, z) to (endX, z-len)
                // We use a custom ShapeGeometry to allow the "bend"
                
                const w = GAME_CONFIG.roadWidth / 2;
                
                // 4 corners of the road quad
                // Local coordinates logic, but we map them to world space inside the geometry construction
                // Actually, easier to place the group at Z and rely on world coords
                
                const roadGeo = new THREE.BufferGeometry();
                
                // Vertices: BL, BR, TL, TR
                // Start points
                const x1 = this.startX - w; 
                const x2 = this.startX + w;
                const z1 = this.zPos;

                // End points
                const x3 = this.endX - w;
                const x4 = this.endX + w;
                const z2 = this.zPos - this.length;

                const vertices = new Float32Array([
                    x1, 0.05, z1,
                    x2, 0.05, z1,
                    x3, 0.05, z2,
                    
                    x2, 0.05, z1,
                    x4, 0.05, z2,
                    x3, 0.05, z2
                ]);

                roadGeo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                roadGeo.computeVertexNormals();

                const roadMat = new THREE.MeshPhongMaterial({ color: COLORS.road });
                this.mesh = new THREE.Mesh(roadGeo, roadMat);
                this.mesh.receiveShadow = true;
                this.container.add(this.mesh);

                // Add Dashed Line Center
                // We create a smaller strip in the middle
                const stripW = 0.5;
                const sx1 = this.startX - stripW; const sx2 = this.startX + stripW;
                const sx3 = this.endX - stripW; const sx4 = this.endX + stripW;
                
                const stripVerts = new Float32Array([
                    sx1, 0.06, z1, sx2, 0.06, z1, sx3, 0.06, z2,
                    sx2, 0.06, z1, sx4, 0.06, z2, sx3, 0.06, z2
                ]);
                const stripGeo = new THREE.BufferGeometry();
                stripGeo.setAttribute('position', new THREE.BufferAttribute(stripVerts, 3));
                const stripMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                this.strip = new THREE.Mesh(stripGeo, stripMat);
                this.container.add(this.strip);

                // Store collision boundaries for this segment
                this.bounds = {
                    zStart: z1,
                    zEnd: z2,
                    leftLineStart: x1,
                    rightLineStart: x2,
                    leftLineEnd: x3,
                    rightLineEnd: x4
                };
            }

            addObstacles() {
                // Barriers on edges
                const numBarriers = 3;
                const barrierGeo = new THREE.BoxGeometry(1, 1.5, 4);
                // Create a red/white striped texture
                const canvas = document.createElement('canvas');
                canvas.width = 64; canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,64,64);
                ctx.fillStyle = '#ff0000'; ctx.fillRect(0,0,32,32); ctx.fillRect(32,32,32,32);
                const tex = new THREE.CanvasTexture(canvas);
                tex.magFilter = THREE.NearestFilter;
                
                const barrierMat = new THREE.MeshLambertMaterial({ map: tex });

                for(let i=0; i<numBarriers; i++) {
                    const t = i / numBarriers;
                    // Interpolate position along the segment edges
                    const curX_L = THREE.MathUtils.lerp(this.startX, this.endX, t) - (GAME_CONFIG.roadWidth/2) - 1;
                    const curX_R = THREE.MathUtils.lerp(this.startX, this.endX, t) + (GAME_CONFIG.roadWidth/2) + 1;
                    const curZ = THREE.MathUtils.lerp(this.zPos, this.zPos - this.length, t);

                    const bLeft = new THREE.Mesh(barrierGeo, barrierMat);
                    bLeft.position.set(curX_L, 0.75, curZ);
                    bLeft.castShadow = true;
                    bLeft.receiveShadow = true;
                    this.container.add(bLeft);

                    const bRight = bLeft.clone();
                    bRight.position.set(curX_R, 0.75, curZ);
                    this.container.add(bRight);
                }
            }

            addEnvironment() {
                // Add mountains/rocks on the sides
                if (Math.random() > 0.3) return; // Not every segment needs them

                const geo = new THREE.ConeGeometry(Math.random() * 10 + 5, Math.random() * 30 + 10, 4); // Low poly look
                const mat = new THREE.MeshFlatShadingMaterial ? new THREE.MeshFlatShadingMaterial() : new THREE.MeshLambertMaterial({color: COLORS.mountain, flatShading: true});
                
                const rock = new THREE.Mesh(geo, mat);
                
                // Position far left or right
                const side = Math.random() > 0.5 ? 1 : -1;
                const offset = (GAME_CONFIG.roadWidth/2) + 20 + Math.random() * 30;
                
                // Interpolate Z center
                const midZ = this.zPos - (this.length/2);
                const midX = (this.startX + this.endX)/2;

                rock.position.set(midX + (offset * side), rock.geometry.parameters.height/2 - 2, midZ);
                rock.rotation.y = Math.random() * Math.PI;
                rock.castShadow = true;
                rock.receiveShadow = true;